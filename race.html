<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duo Racer</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --duo-green: #58CC02;
            --duo-green-shadow: #46A302;
            --duo-blue: #1CB0F6;
            --duo-blue-shadow: #1899D6;
            --duo-red: #FF4B4B;
            --duo-red-shadow: #D33131;
            --duo-yellow: #FFC800;
            --duo-yellow-shadow: #D7A605;
            --duo-gray: #E5E5E5;
            --duo-text: #4B4B4B;
            --bg-color: #f0f4f8; 
        }

        body {
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-color);
            color: var(--duo-text);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        /* --- UI CARDS --- */
        .card {
            background: white;
            padding: 2.5rem;
            border-radius: 24px;
            border: 2px solid var(--duo-gray);
            box-shadow: 0 6px 0 var(--duo-gray);
            text-align: center;
            max-width: 420px;
            width: 90%;
            transition: transform 0.2s;
            z-index: 20;
            position: relative;
        }

        h1 {
            color: var(--duo-green);
            font-weight: 900;
            font-size: 2.2rem;
            margin: 0 0 0.5rem 0;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 2px 2px 0 #daf5c6;
        }

        p {
            color: #afafaf;
            font-weight: 700;
            margin-bottom: 2rem;
            line-height: 1.5;
        }

        /* --- INPUTS & BUTTONS --- */
        .input-group {
            position: relative;
            margin-bottom: 1rem;
        }

        input[type="text"] {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid var(--duo-gray);
            border-radius: 16px;
            font-family: 'Nunito', sans-serif;
            font-size: 1.1rem;
            font-weight: 800;
            color: var(--duo-text);
            box-sizing: border-box;
            outline: none;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: #fdfdfd;
            transition: all 0.2s;
        }

        input[type="text"]:focus {
            border-color: var(--duo-blue);
            background: #fff;
        }

        .btn {
            display: block;
            width: 100%;
            padding: 16px 0;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
            font-size: 1.1rem;
            text-transform: uppercase;
            color: white;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            position: relative;
            top: 0;
            transition: all 0.1s;
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .btn:active { top: 4px; box-shadow: none !important; transform: translateY(2px); }

        .btn-primary { background-color: var(--duo-green); box-shadow: 0 5px 0 var(--duo-green-shadow); }
        .btn-secondary { background-color: var(--duo-blue); box-shadow: 0 5px 0 var(--duo-blue-shadow); }
        .btn-yellow { background-color: var(--duo-yellow); box-shadow: 0 5px 0 var(--duo-yellow-shadow); color: #4B4B4B; }

        .hidden { display: none !important; }
        .divider { height: 2px; background: #f0f0f0; margin: 20px 0; border-radius: 2px; }

        /* --- GAME CONTAINER --- */
        #game-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            width: 90%;
            max-width: 600px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 24px;
            border-radius: 20px;
            border: 3px solid var(--duo-gray);
            box-shadow: 0 6px 0 rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 8px;
            backdrop-filter: blur(5px);
        }

        .progress-track {
            height: 18px;
            background: #eef2f5;
            border-radius: 9px;
            position: relative;
            overflow: hidden;
            width: 100%;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            border-radius: 9px;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #p1-bar { background: var(--duo-green); }
        #p2-bar { background: var(--duo-blue); }
        
        .hud-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            font-weight: 900;
            color: #b0b0b0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* --- MODAL --- */
        #modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(30, 40, 50, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(8px);
        }

        .id-display {
            font-size: 2.5rem;
            font-weight: 900;
            color: var(--duo-blue);
            letter-spacing: 8px;
            margin: 10px 0;
            background: #f0f8ff;
            padding: 10px;
            border-radius: 12px;
            border: 2px dashed #bce0fd;
        }

        .control-hint {
            position: absolute;
            bottom: 20px;
            color: rgba(255,255,255,0.8);
            font-weight: 700;
            font-size: 0.9rem;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>


    <!-- CAR SELECTION -->
    <div id="car-select" class="card">
        <h1>Choose Your Car</h1>
        <div id="car-options" style="display: flex; gap: 1.2rem; justify-content: center; flex-wrap: wrap; margin-bottom: 1.5rem;"></div>
        <button id="car-confirm" class="btn btn-primary" disabled>Confirm Selection</button>
    </div>

    <!-- LOBBY -->
    <div id="lobby" class="card hidden">
        <h1>Duo Racer</h1>
        <p>Speed learning? No, just speed.</p>
        <!-- Loading State -->
        <div id="loading-panel">
            <p style="color: var(--duo-blue);">Connecting to satellite...</p>
        </div>
        <!-- Main Menu -->
        <div id="main-menu" class="hidden">
            <button id="single-player-btn" class="btn btn-yellow">Practice Solo</button>
            <div class="divider"></div>
            <div style="margin-bottom: 20px;">
                <p style="margin-bottom: 10px; font-size: 0.9rem;">MULTIPLAYER</p>
                <div class="id-display" id="my-peer-id">----</div>
                <p style="margin-bottom: 0; font-size: 0.8rem; margin-top: 5px;">Your Room Code</p>
            </div>
            <div class="input-group">
                <input type="text" id="friend-id-input" placeholder="ENTER FRIEND'S CODE" maxlength="4">
            </div>
            <button id="join-btn" class="btn btn-secondary">Join Friend</button>
        </div>
    </div>

    <!-- GAME UI -->
    <div id="game-container">
        <div id="hud">
            <div class="hud-labels">
                <span>Distance</span>
                <span>Goal</span>
            </div>
            <div class="progress-track"><div id="p1-bar" class="progress-fill"></div></div>
            <div class="progress-track"><div id="p2-bar" class="progress-fill"></div></div>
            <div style="margin-top:10px;">
                <div style="font-size:0.85rem;font-weight:900;color:#b0b0b0;text-transform:uppercase;letter-spacing:0.5px;">Nitro</div>
                <div class="progress-track" style="height:14px;background:#e0e7ef;">
                    <div id="nitro-bar" class="progress-fill" style="background:#FFC800;width:0%;transition:width 0.2s;"></div>
                </div>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="control-hint">Tap / Up Arrow to Accelerate &bull; Left/Right to Steer</div>
    </div>

    <!-- GAME OVER MODAL -->
    <div id="modal-overlay">
        <div class="card">
            <h1 id="result-title">FINISHED!</h1>
            <p id="result-msg">Good game.</p>
            <button onclick="location.reload()" class="btn btn-primary">MAIN MENU</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CAR_STATS = [
            { name: "Sprinter", color: "#58CC02", speed: 22, accel: 0.5, handling: 6, nitro: 2.5, desc: "Balanced all-rounder." },
            { name: "Blaze", color: "#FF4B4B", speed: 25, accel: 0.38, handling: 5, nitro: 3.2, desc: "Fastest top speed, weak handling." },
            { name: "Drifter", color: "#1CB0F6", speed: 20, accel: 0.6, handling: 8, nitro: 2.0, desc: "Best handling, quick start." },
            { name: "NitroX", color: "#FFC800", speed: 21, accel: 0.45, handling: 6, nitro: 4.0, desc: "Huge nitro boost!" }
        ];
        let selectedCarIdx = null;
        const CONFIG = {
            roadWidthPercent: 0.5,
            totalDistance: 6000,
            maxSpeed: 22, // Will be overwritten by car
            colors: {
                grassLight: "#8DE356",
                grassDark: "#82D64D", // Slight striping
                road: "#57606f",
                skyTop: "#a2dbf5",
                skyBottom: "#d8f0fa",
                rumble1: "#ffffff",
                rumble2: "#ff4757"
            }
        };

        // --- STATE ---
        let peer, conn;
        let myId, friendId;
        let isSinglePlayer = false;
        let gameActive = false;
        let frameCount = 0;

        // Player State
        let players = {
            p1: { x: 0, distance: 0, speed: 0, color: '#58CC02', label: 'YOU', nitro: 0, nitroMax: 100, nitroActive: false, nitroTimer: 0, drifting: false, driftDir: 0, driftTime: 0, driftBoost: 0 }, // Green
            p2: { x: 0, distance: 0, speed: 0, color: '#1CB0F6', label: 'RIVAL', nitro: 0, nitroMax: 100, nitroActive: false, nitroTimer: 0, drifting: false, driftDir: 0, driftTime: 0, driftBoost: 0 }  // Blue
        };
        let me = 'p1';
        let them = 'p2';

        // Scenery Objects (Trees, bushes)
        let scenery = [];
        // Soothing sky elements
        let clouds = [];
        let birds = [];
        
        // Input
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false, a: false, d: false };

        // DOM
        const els = {
            carSelect: document.getElementById('car-select'),
            carOptions: document.getElementById('car-options'),
            carConfirm: document.getElementById('car-confirm'),
            lobby: document.getElementById('lobby'),
            loading: document.getElementById('loading-panel'),
            menu: document.getElementById('main-menu'),
            game: document.getElementById('game-container'),
            canvas: document.getElementById('gameCanvas'),
            myId: document.getElementById('my-peer-id'),
            joinBtn: document.getElementById('join-btn'),
            friendInput: document.getElementById('friend-id-input'),
            p1Bar: document.getElementById('p1-bar'),
            p2Bar: document.getElementById('p2-bar'),
            nitroBar: null
        };
        setTimeout(() => { els.nitroBar = document.getElementById('nitro-bar'); }, 0);

        // --- CAR SELECTION UI ---
        function renderCarOptions() {
            els.carOptions.innerHTML = '';
            CAR_STATS.forEach((car, idx) => {
                const div = document.createElement('div');
                div.className = 'car-option';
                div.style.cssText = `background: ${car.color}; border-radius: 16px; padding: 1rem 0.7rem; width: 110px; box-shadow: 0 2px 0 #bbb; cursor: pointer; border: 3px solid transparent; display: flex; flex-direction: column; align-items: center;`;
                div.innerHTML = `<div style='width:48px;height:32px;background:${car.color};border-radius:10px 10px 16px 16px/16px 16px 10px 10px;box-shadow:0 2px 0 #333; margin-bottom: 0.5rem;'></div>
                <b style='color:#222;font-size:1.1em;'>${car.name}</b>
                <span style='font-size:0.9em;'>${car.desc}</span>
                <div style='font-size:0.8em;margin-top:0.5em;'>
                    <span>ðŸš€${car.speed}</span> <span>âš¡${car.accel}</span> <span>ðŸŽ¯${car.handling}</span> <span>ðŸ’¥${car.nitro}</span>
                </div>`;
                div.onclick = () => {
                    selectedCarIdx = idx;
                    Array.from(els.carOptions.children).forEach((c, i) => c.style.borderColor = i === idx ? '#1CB0F6' : 'transparent');
                    els.carConfirm.disabled = false;
                };
                els.carOptions.appendChild(div);
            });
        }
        renderCarOptions();
        els.carConfirm.onclick = () => {
            if (selectedCarIdx === null) return;
            // Set player car stats
            const car = CAR_STATS[selectedCarIdx];
            players.p1.color = car.color;
            players.p1.label = car.name.toUpperCase();
            CONFIG.maxSpeed = car.speed;
            players.p1.accel = car.accel;
            players.p1.handling = car.handling;
            players.p1.nitro = car.nitro;
            players.p1.nitroMax = Math.round(car.nitro * 25 + 75); // scale to 100-175
            players.p1.nitro = players.p1.nitroMax;
            // Hide car select, show lobby
            els.carSelect.classList.add('hidden');
            els.lobby.classList.remove('hidden');
        };
        // Hide lobby until car is picked
        els.lobby.classList.add('hidden');
        els.carSelect.classList.remove('hidden');

    const ctx = els.canvas.getContext('2d');

        // --- INIT ---
        // Generate a 4-letter ID
        const generateId = () => {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let res = '';
            for(let i=0; i<4; i++) res += chars.charAt(Math.floor(Math.random() * chars.length));
            return res;
        };

        const shortId = generateId();
        peer = new Peer(shortId);

        peer.on('open', (id) => {
            els.loading.classList.add('hidden');
            els.menu.classList.remove('hidden');
            els.myId.innerText = id;
            myId = id;
        });

        peer.on('error', (err) => {
            // Fallback if ID taken (rare)
            if (err.type === 'unavailable-id') {
                location.reload(); 
            }
            console.error(err);
        });

        peer.on('connection', (connection) => {
            if (gameActive) return; // Busy
            handleConnection(connection);
        });

        // --- BUTTON HANDLERS ---
        
        // Single Player
            document.getElementById('single-player-btn').addEventListener('click', () => {
                isSinglePlayer = true;
                me = 'p1';
                them = 'p2';
                // Set rival color to red for single player to distinguish
                players.p2.color = '#FF4B4B'; 
                players.p2.label = 'BOT';
                startCountdownAndGame();
            });

        // Join Friend
        els.joinBtn.addEventListener('click', () => {
            const fid = els.friendInput.value.trim().toUpperCase();
            if (fid.length < 4) return;
            
            els.joinBtn.innerText = "CONNECTING...";
            conn = peer.connect(fid);
            
            conn.on('open', () => {
                // If I join, I am P2
                me = 'p2';
                them = 'p1';
                    startCountdownAndGame();
            });

            handleConnection(conn);
        });

        function handleConnection(connection) {
            conn = connection;
            // Common handlers
            conn.on('data', (data) => {
                if (data.type === 'update') {
                    players[them].distance = data.distance;
                    players[them].x = data.x;
                } else if (data.type === 'gameover') {
                    endGame(data.winner);
                }
            });
            
            // If we received connection, start game
                if (!isSinglePlayer && conn.open) {
                     startCountdownAndGame();
            } else if (!isSinglePlayer) {
                    conn.on('open', startCountdownAndGame);
            }
        }

        // --- GAME LOGIC ---
        function startGame() {
            els.lobby.classList.add('hidden');
            els.game.style.display = 'flex';
            resize();
            gameActive = true;
            generateScenery();
            requestAnimationFrame(loop);
        }

        function resize() {
            els.canvas.width = window.innerWidth;
            els.canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);

        // Input Listeners
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);
        window.addEventListener('touchstart', () => keys.ArrowUp = true);
        window.addEventListener('touchend', () => keys.ArrowUp = false);

        function loop() {
            if (!gameActive) return;
                // Block input during countdown
                if (countdownActive) return;
                update();
                draw();
                frameCount++;
                requestAnimationFrame(loop);
        }
            // --- COUNTDOWN ---
            let countdownActive = false;
            let countdownValue = 3;
            let countdownInterval = null;

            // Add countdown overlay
            let countdownDiv = document.createElement('div');
            countdownDiv.id = 'countdown-overlay';
            countdownDiv.style.position = 'fixed';
            countdownDiv.style.top = '0';
            countdownDiv.style.left = '0';
            countdownDiv.style.width = '100vw';
            countdownDiv.style.height = '100vh';
            countdownDiv.style.display = 'flex';
            countdownDiv.style.alignItems = 'center';
            countdownDiv.style.justifyContent = 'center';
            countdownDiv.style.zIndex = '200';
            countdownDiv.style.background = 'rgba(240,244,248,0.7)';
            countdownDiv.style.fontFamily = "Nunito, sans-serif";
            countdownDiv.style.fontWeight = '900';
            countdownDiv.style.fontSize = '7rem';
            countdownDiv.style.color = '#1CB0F6';
            countdownDiv.style.textShadow = '0 4px 0 #fff, 0 8px 16px #1CB0F633';
            countdownDiv.style.userSelect = 'none';
            countdownDiv.style.pointerEvents = 'none';
            countdownDiv.innerText = '';
            document.body.appendChild(countdownDiv);
            countdownDiv.style.display = 'none';

            function startCountdownAndGame() {
                els.lobby.classList.add('hidden');
                els.game.style.display = 'flex';
                resize();
                generateScenery();
                countdownValue = 3;
                countdownActive = true;
                countdownDiv.innerText = countdownValue;
                countdownDiv.style.display = 'flex';
                if (countdownInterval) clearInterval(countdownInterval);
                countdownInterval = setInterval(() => {
                    countdownValue--;
                    if (countdownValue > 0) {
                        countdownDiv.innerText = countdownValue;
                    } else if (countdownValue === 0) {
                        countdownDiv.innerText = 'GO!';
                        countdownDiv.style.color = '#58CC02';
                    } else {
                        clearInterval(countdownInterval);
                        countdownDiv.style.display = 'none';
                        countdownActive = false;
                        gameActive = true;
                        requestAnimationFrame(loop);
                    }
                }, 800);

        function update() {
            const p = players[me];

            // --- Drift Mechanic ---
            let steering = 0;
            if ((keys.ArrowLeft || keys.a) && p.x > -150) steering = -1;
            if ((keys.ArrowRight || keys.d) && p.x < 150) steering = 1;
            let braking = keys.ArrowDown || keys.s;
            // Start drift if braking and steering
            if (!p.drifting && braking && steering !== 0 && p.speed > 6) {
                p.drifting = true;
                p.driftDir = steering;
                p.driftTime = 0;
                p.driftBoost = 0;
            }
            // Continue drift
            if (p.drifting) {
                p.driftTime++;
                // More handling while drifting
                let driftHandling = (p.handling || 6) * 1.7;
                p.x += p.driftDir * driftHandling;
                // Lose a bit of speed
                p.speed -= 0.08;
                if (p.speed < 0) p.speed = 0;
                // Build up drift boost
                if (p.driftTime > 10) p.driftBoost += 0.12;
                // End drift if brake or steer released
                if (!braking || steering !== p.driftDir) {
                    p.drifting = false;
                    // Give a speed boost for drifting
                    if (p.driftBoost > 0.5) p.speed += Math.min(3 + p.driftBoost, 8);
                    p.driftBoost = 0;
                }
            }

            // --- Nitro Logic ---
            // Spacebar or Shift for nitro
            let nitroPressed = keys[' '] || keys['Shift'] || keys['ShiftLeft'] || keys['ShiftRight'];
            if (nitroPressed && p.nitro > 0) {
                p.nitroActive = true;
                p.nitroTimer++;
                p.nitro -= 1.2 + 0.2 * (p.nitroTimer/60); // drains faster the longer you hold
                if (p.nitro < 0) p.nitro = 0;
            } else {
                p.nitroActive = false;
                p.nitroTimer = 0;
                // Recharge slowly if not full
                if (p.nitro < p.nitroMax) p.nitro += 0.5;
            }
            if (p.nitro > p.nitroMax) p.nitro = p.nitroMax;

            // 1. My Physics
            let maxSpd = CONFIG.maxSpeed + (p.nitroActive ? 7 : 0);
            if (keys.ArrowUp || keys.w) {
                p.speed < maxSpd ? p.speed += 0.4 + (p.nitroActive ? 0.25 : 0) : p.speed = maxSpd;
            } else {
                p.speed > 0 ? p.speed -= 0.3 : p.speed = 0;
            }
            // Simple lane logic (if not drifting)
            if (!p.drifting) {
                let handling = p.handling || 6;
                if ((keys.ArrowLeft || keys.a) && p.x > -150) p.x -= handling;
                if ((keys.ArrowRight || keys.d) && p.x < 150) p.x += handling;
            }

            p.distance += p.speed;

            // 2. Single Player AI
            if (isSinglePlayer) {
                const bot = players[them];
                // Rubber banding AI
                const diff = p.distance - bot.distance;
                let targetSpeed = CONFIG.maxSpeed * 0.92; // Base speed
                // If bot is far behind, speed up. If ahead, slow down.
                if (diff > 500) targetSpeed = CONFIG.maxSpeed * 1.1;
                if (diff < -500) targetSpeed = CONFIG.maxSpeed * 0.8;
                // Bot uses nitro if behind
                if (diff > 400 && bot.nitro > 0) {
                    bot.nitroActive = true;
                    bot.nitro -= 1.1;
                    targetSpeed += 5;
                } else {
                    bot.nitroActive = false;
                    if (bot.nitro < bot.nitroMax) bot.nitro += 0.5;
                }
                if (bot.nitro < 0) bot.nitro = 0;
                if (bot.nitro > bot.nitroMax) bot.nitro = bot.nitroMax;
                if (bot.speed < targetSpeed) bot.speed += 0.2;
                else bot.speed -= 0.2;
                bot.distance += bot.speed;
                // Simple sway
                bot.x = Math.sin(frameCount / 50) * 50;
            }

            // 3. Multiplayer Sync
            if (!isSinglePlayer && conn && conn.open && frameCount % 3 === 0) {
                conn.send({ type: 'update', distance: p.distance, x: p.x });
            }

            // 4. Win Condition
            if (p.distance >= CONFIG.totalDistance) {
                finish(me);
            } else if (players[them].distance >= CONFIG.totalDistance) {
                finish(them);
            }

            // 5. HUD
            els.p1Bar.style.width = `${Math.min(100, (players.p1.distance / CONFIG.totalDistance)*100)}%`;
            els.p2Bar.style.width = `${Math.min(100, (players.p2.distance / CONFIG.totalDistance)*100)}%`;
            if (els.nitroBar) {
                let nitroPct = Math.max(0, Math.min(100, (p.nitro / (p.nitroMax || 100)) * 100));
                els.nitroBar.style.width = `${nitroPct}%`;
                els.nitroBar.style.background = p.nitroActive ? '#FF4B4B' : '#FFC800';
            }
        }

        function finish(winner) {
            gameActive = false;
            if (!isSinglePlayer && conn && conn.open) {
                conn.send({ type: 'gameover', winner: winner });
            }
            endGame(winner);
        }

        // --- RENDERING ---
        
        // Procedural Scenery Generation
        function generateScenery() {
            // Create 50 random trees/bushes along the track
            scenery = [];
            for(let i=0; i<60; i++) {
                scenery.push({
                    z: Math.random() * CONFIG.totalDistance, // Position along track
                    side: Math.random() > 0.5 ? -1 : 1, // Left or Right
                    offset: 200 + Math.random() * 300, // Distance from road
                    type: Math.random() > 0.7 ? 'tree' : 'bush',
                    scale: 0.8 + Math.random() * 0.5,
                    color: Math.random() > 0.5 ? '#7bc43d' : '#6ab035'
                });
            }
            scenery.sort((a,b) => a.z - b.z);
            // Soothing sky: clouds and birds
            clouds = [];
            for (let i = 0; i < 7; i++) {
                clouds.push({ x: Math.random(), y: Math.random()*0.18+0.02, w: 0.18+Math.random()*0.12, h: 0.07+Math.random()*0.04, speed: 0.00012+Math.random()*0.00018, opacity: 0.5+Math.random()*0.3 });
            }
            birds = [];
            for (let i = 0; i < 3; i++) {
                birds.push({ x: Math.random(), y: 0.08+Math.random()*0.12, dx: 0.00025+Math.random()*0.0002, phase: Math.random()*Math.PI*2 });
            }
        }

        function draw() {
            const w = els.canvas.width;
            const h = els.canvas.height;
            const cx = w / 2;
            const cy = h / 2;
            // 1. Animated Sky Gradient
            let t = (Date.now() % 120000) / 120000; // 2 min cycle
            let skyTop = `rgb(${180+40*Math.sin(t*2*Math.PI)},${210+30*Math.cos(t*2*Math.PI)},${245})`;
            let skyBot = `rgb(${216+20*Math.cos(t*2*Math.PI)},${240+10*Math.sin(t*2*Math.PI)},${250})`;
            const grd = ctx.createLinearGradient(0, 0, 0, h/2);
            grd.addColorStop(0, skyTop);
            grd.addColorStop(1, skyBot);
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, w, h);
            // 1.2 Clouds
            for (let i = 0; i < clouds.length; i++) {
                let c = clouds[i];
                c.x += c.speed;
                if (c.x > 1.1) c.x = -0.2;
                ctx.save();
                ctx.globalAlpha = c.opacity;
                ctx.fillStyle = '#fff';
                let cx1 = c.x * w;
                let cy1 = c.y * h;
                ctx.beginPath();
                ctx.ellipse(cx1, cy1, c.w*w, c.h*h, 0, 0, Math.PI*2);
                ctx.ellipse(cx1+0.2*c.w*w, cy1+0.1*c.h*h, 0.7*c.w*w, 0.7*c.h*h, 0, 0, Math.PI*2);
                ctx.ellipse(cx1-0.2*c.w*w, cy1+0.1*c.h*h, 0.7*c.w*w, 0.7*c.h*h, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            }
            // 1.3 Birds
            for (let i = 0; i < birds.length; i++) {
                let b = birds[i];
                b.x += b.dx;
                if (b.x > 1.1) b.x = -0.1;
                let bx = b.x * w;
                let by = b.y * h + Math.sin(Date.now()/400 + b.phase)*12;
                ctx.save();
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(bx, by, 12, Math.PI*0.2, Math.PI*0.8, false);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(bx+14, by, 12, Math.PI*0.2, Math.PI*0.8, false);
                ctx.stroke();
                ctx.restore();
            }

            // 2. Ground (Perspective illusion)
            // Just fill bottom half
            ctx.fillStyle = CONFIG.colors.grassLight;
            ctx.fillRect(0, h/2, w, h/2);

            // 3. Road Perspective
            // We use a simple 2.5D projection
            // Objects have a World Z (distance). Screen Y is proportional to 1/Z relative to camera.
            // Camera Z = players[me].distance
            
            // To keep it simple and clean like the previous version, we will stick to 
            // the vertical top-down-ish view but slanted, or just pure vertical scroll 
            // with perspective width. Let's do Vertical Scroll with Perspective Width.
            
            const camZ = players[me].distance;
            const roadW = w * CONFIG.roadWidthPercent;
            const horizonY = h * 0.3; // Horizon line height
            
            // Draw Ground Stripes
            const stripeH = 100;
            const groundOffset = -(camZ % (stripeH * 2));
            
            // Draw Scenery first (behind road?) No, scenery sits on ground.
            // We draw items that are visible.
            
            // Draw Road
            ctx.beginPath();
            ctx.fillStyle = CONFIG.colors.road;
            ctx.moveTo(cx - roadW * 0.1, horizonY); // Top Left (Vanishing point ish)
            ctx.lineTo(cx + roadW * 0.1, horizonY); // Top Right
            ctx.lineTo(cx + roadW/2, h);            // Bottom Right
            ctx.lineTo(cx - roadW/2, h);            // Bottom Left
            ctx.fill();

            // Draw Rumble Strips & Lane Markers
            // We iterate from near (bottom) to far (top)
            // However, iterating screen Y is easier.
            const totalStripes = 20;
            for(let i=0; i<totalStripes; i++) {
                // Perspective math: non-linear steps
                // Let's fake it with simple geometry for aesthetics
                let y = h - (h - horizonY) * (i / totalStripes);
                let nextY = h - (h - horizonY) * ((i+1) / totalStripes);
                
                let scale = 1 - (i/totalStripes); // 1 at bottom, 0 at top
                let nextScale = 1 - ((i+1)/totalStripes);

                let rw = (roadW/2) * (0.2 + 0.8*scale); // Road width at this Y
                
                // Movement
                let worldZ = camZ + (1000 * (i/totalStripes)); 
                let segmentColor = Math.floor(worldZ / 400) % 2 === 0; // Alternating segments

                // Rumble Strips
                if (segmentColor) {
                    ctx.fillStyle = CONFIG.colors.rumble2;
                    ctx.fillRect(cx - rw - 15*scale, nextY, 15*scale, y-nextY); // Left
                    ctx.fillRect(cx + rw, nextY, 15*scale, y-nextY); // Right
                } else {
                     ctx.fillStyle = CONFIG.colors.rumble1;
                    ctx.fillRect(cx - rw - 15*scale, nextY, 15*scale, y-nextY);
                    ctx.fillRect(cx + rw, nextY, 15*scale, y-nextY);
                }

                // Center Line
                if (Math.floor(worldZ / 200) % 2 === 0) {
                     ctx.fillStyle = "#FFF";
                     ctx.fillRect(cx - 2*scale, nextY, 4*scale, y-nextY);
                }
            }

            // 4. Draw Scenery Objects
            // Filter objects visible in front of camera
            const visibleScenery = scenery.filter(obj => obj.z > camZ - 200 && obj.z < camZ + 4000);
            
            // Sort: Furthest first (high Z) so near ones cover them
            visibleScenery.sort((a,b) => b.z - a.z);

            visibleScenery.forEach(obj => {
                // Projection
                let relZ = obj.z - camZ;
                let depth = relZ / 4000; // 0 (near) to 1 (far)
                if (depth < 0) depth = 0;
                
                let y = h - (h - horizonY) * (1 - Math.pow(1-depth, 2)); // Ease out
                let scale = (1 - depth); 
                
                // X position moves outward with perspective
                let xOffset = (obj.offset + roadW * 0.5) * scale * obj.side;
                let x = cx + xOffset;

                drawTree(ctx, x, y, scale * obj.scale, obj.color, obj.type);
            });

            // 5. Draw Cars
            // Me
            drawCar(ctx, cx + players[me].x, h - 120, players[me].color, true, players[me].label);

            // Opponent
            const distDiff = players[them].distance - players[me].distance;
            // Map distance to screen Y using the same perspective fake
            // This is tricky in 2.5D. We'll approximate.
            // If they are ahead (pos diff), they move up towards horizonY.
            // If behind, move down.
            
            let rivalScale = 1;
            let rivalY = h - 120;

            if (Math.abs(distDiff) < 3000) {
                // Simple linear map for demo
                rivalY -= distDiff * 0.4; 
                
                // Add scaling based on Y position (pseudo perspective)
                let progressToHorizon = (h - rivalY) / (h - horizonY);
                rivalScale = 1 - (progressToHorizon * 0.8);
                
                if (rivalY > horizonY && rivalY < h + 200) {
                     // Their X also needs to scale
                     let theirX = (cx + players[them].x * rivalScale);
                     // If behind, we need to invert perspective slightly or clamp
                     drawCar(ctx, theirX, rivalY, players[them].color, false, players[them].label, rivalScale);
                }
            }
        }

        function drawTree(ctx, x, y, s, color, type) {
            if (s <= 0) return;
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(s, s);

            if (type === 'tree') {
                // Trunk
                ctx.fillStyle = "#8d6e63";
                ctx.fillRect(-10, -20, 20, 20);
                // Leaves (Round)
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(0, -50, 40, 0, Math.PI*2);
                ctx.fill();
                // Shadow/Highlight
                ctx.fillStyle = "rgba(255,255,255,0.2)";
                ctx.beginPath();
                ctx.arc(-10, -60, 15, 0, Math.PI*2);
                ctx.fill();
            } else {
                // Bush
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(0, -10, 25, 0, Math.PI*2);
                ctx.arc(-20, 0, 15, 0, Math.PI*2);
                ctx.arc(20, 0, 15, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawCar(ctx, x, y, color, isMe, label, scale = 1) {
            const w = 70 * scale;
            const h = 50 * scale;
            ctx.save();
            ctx.translate(x, y);
            // Shadow
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.beginPath();
            ctx.ellipse(0, h/2, w/1.8, w/4, 0, 0, Math.PI * 2);
            ctx.fill();
            // Body
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(-w/2, -h/2, w, h, 15 * scale);
            ctx.fill();
            // Nitro flames (if active)
            if (isMe && players[me].nitroActive) {
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = '#FFC800';
                ctx.beginPath();
                ctx.ellipse(0, h/2 + 12*scale, 16*scale, 8*scale, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#FF4B4B';
                ctx.beginPath();
                ctx.ellipse(0, h/2 + 22*scale, 24*scale, 12*scale, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            }
            // Drift sparks (if drifting)
            if (isMe && players[me].drifting) {
                for (let i = 0; i < 6; i++) {
                    let ang = Math.PI + (Math.random() - 0.5) * 0.7;
                    let r = 30 * scale + Math.random() * 10;
                    let sx = Math.cos(ang) * r;
                    let sy = Math.sin(ang) * r + h/2;
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(sx, sy, 2.5*scale, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = '#FF4B4B';
                    ctx.beginPath();
                    ctx.arc(sx, sy, 4*scale, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            // Shine
            ctx.fillStyle = "rgba(255,255,255,0.2)";
            ctx.fillRect(-w/2, -h/2, w, h/2);
            // Windows
            ctx.fillStyle = "#333";
            ctx.beginPath();
            ctx.roundRect(-w/2 + 5*scale, -h/2 + 5*scale, w - 10*scale, h*0.4, 5*scale);
            ctx.fill();
            // Label
            if (scale > 0.4) {
                ctx.fillStyle = "white";
                ctx.font = `900 ${14*scale}px Nunito`;
                ctx.textAlign = "center";
                ctx.fillText(label, 0, -h/2 - 10*scale);
            }
            ctx.restore();
        }

        function endGame(winner) {
            const modal = document.getElementById('modal-overlay');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-msg');
            
            modal.style.display = 'flex';
            
            if (winner === me) {
                title.innerText = "VICTORY!";
                title.style.color = "#58CC02";
                msg.innerText = isSinglePlayer ? "You beat the bot!" : "You beat your friend!";
            } else {
                title.innerText = "SECOND PLACE";
                title.style.color = "#FF4B4B";
                msg.innerText = "Nice try!";
            }
        }
    </script>
</body>
</html>