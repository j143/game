<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duo Racer</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --duo-green: #58CC02;
            --duo-green-shadow: #46A302;
            --duo-blue: #1CB0F6;
            --duo-blue-shadow: #1899D6;
            --duo-red: #FF4B4B;
            --duo-red-shadow: #D33131;
            --duo-yellow: #FFC800;
            --duo-yellow-shadow: #D7A605;
            --duo-gray: #E5E5E5;
            --duo-text: #4B4B4B;
            --bg-color: #f0f4f8; 
        }

        body {
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-color);
            color: var(--duo-text);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        /* --- UI CARDS --- */
        .card {
            background: white;
            padding: 2.5rem;
            border-radius: 24px;
            border: 2px solid var(--duo-gray);
            box-shadow: 0 6px 0 var(--duo-gray);
            text-align: center;
            max-width: 420px;
            width: 90%;
            transition: transform 0.2s;
            z-index: 20;
            position: relative;
        }

        h1 {
            color: var(--duo-green);
            font-weight: 900;
            font-size: 2.2rem;
            margin: 0 0 0.5rem 0;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 2px 2px 0 #daf5c6;
        }

        p {
            color: #afafaf;
            font-weight: 700;
            margin-bottom: 2rem;
            line-height: 1.5;
        }

        /* --- INPUTS & BUTTONS --- */
        .input-group {
            position: relative;
            margin-bottom: 1rem;
        }

        input[type="text"] {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid var(--duo-gray);
            border-radius: 16px;
            font-family: 'Nunito', sans-serif;
            font-size: 1.1rem;
            font-weight: 800;
            color: var(--duo-text);
            box-sizing: border-box;
            outline: none;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: #fdfdfd;
            transition: all 0.2s;
        }

        input[type="text"]:focus {
            border-color: var(--duo-blue);
            background: #fff;
        }

        .btn {
            display: block;
            width: 100%;
            padding: 16px 0;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
            font-size: 1.1rem;
            text-transform: uppercase;
            color: white;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            position: relative;
            top: 0;
            transition: all 0.1s;
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .btn:active { top: 4px; box-shadow: none !important; transform: translateY(2px); }

        .btn-primary { background-color: var(--duo-green); box-shadow: 0 5px 0 var(--duo-green-shadow); }
        .btn-secondary { background-color: var(--duo-blue); box-shadow: 0 5px 0 var(--duo-blue-shadow); }
        .btn-yellow { background-color: var(--duo-yellow); box-shadow: 0 5px 0 var(--duo-yellow-shadow); color: #4B4B4B; }

        .hidden { display: none !important; }
        .divider { height: 2px; background: #f0f0f0; margin: 20px 0; border-radius: 2px; }

        /* --- GAME CONTAINER --- */
        #game-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            width: 90%;
            max-width: 600px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 24px;
            border-radius: 20px;
            border: 3px solid var(--duo-gray);
            box-shadow: 0 6px 0 rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 8px;
            backdrop-filter: blur(5px);
        }

        .progress-track {
            height: 18px;
            background: #eef2f5;
            border-radius: 9px;
            position: relative;
            overflow: hidden;
            width: 100%;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            border-radius: 9px;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #p1-bar { background: var(--duo-green); }
        #p2-bar { background: var(--duo-blue); }
        
        .hud-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            font-weight: 900;
            color: #b0b0b0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* --- MODAL --- */
        #modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(30, 40, 50, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(8px);
        }

        .id-display {
            font-size: 2.5rem;
            font-weight: 900;
            color: var(--duo-blue);
            letter-spacing: 8px;
            margin: 10px 0;
            background: #f0f8ff;
            padding: 10px;
            border-radius: 12px;
            border: 2px dashed #bce0fd;
        }

        .control-hint {
            position: absolute;
            bottom: 20px;
            color: rgba(255,255,255,0.8);
            font-weight: 700;
            font-size: 0.9rem;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>

    <!-- LOBBY -->
    <div id="lobby" class="card">
        <h1>Duo Racer</h1>
        <p>Speed learning? No, just speed.</p>
        
        <!-- Loading State -->
        <div id="loading-panel">
            <p style="color: var(--duo-blue);">Connecting to satellite...</p>
        </div>

        <!-- Main Menu -->
        <div id="main-menu" class="hidden">
            <button id="single-player-btn" class="btn btn-yellow">Practice Solo</button>
            <div class="divider"></div>
            
            <div style="margin-bottom: 20px;">
                <p style="margin-bottom: 10px; font-size: 0.9rem;">MULTIPLAYER</p>
                <div class="id-display" id="my-peer-id">----</div>
                <p style="margin-bottom: 0; font-size: 0.8rem; margin-top: 5px;">Your Room Code</p>
            </div>

            <div class="input-group">
                <input type="text" id="friend-id-input" placeholder="ENTER FRIEND'S CODE" maxlength="4">
            </div>
            <button id="join-btn" class="btn btn-secondary">Join Friend</button>
        </div>
    </div>

    <!-- GAME UI -->
    <div id="game-container">
        <div id="hud">
            <div class="hud-labels">
                <span>Distance</span>
                <span>Goal</span>
            </div>
            <div class="progress-track"><div id="p1-bar" class="progress-fill"></div></div>
            <div class="progress-track"><div id="p2-bar" class="progress-fill"></div></div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="control-hint">Tap / Up Arrow to Accelerate &bull; Left/Right to Steer</div>
    </div>

    <!-- GAME OVER MODAL -->
    <div id="modal-overlay">
        <div class="card">
            <h1 id="result-title">FINISHED!</h1>
            <p id="result-msg">Good game.</p>
            <button onclick="location.reload()" class="btn btn-primary">MAIN MENU</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            roadWidthPercent: 0.5,
            totalDistance: 6000,
            maxSpeed: 22,
            colors: {
                grassLight: "#8DE356",
                grassDark: "#82D64D", // Slight striping
                road: "#57606f",
                skyTop: "#a2dbf5",
                skyBottom: "#d8f0fa",
                rumble1: "#ffffff",
                rumble2: "#ff4757"
            }
        };

        // --- STATE ---
        let peer, conn;
        let myId, friendId;
        let isSinglePlayer = false;
        let gameActive = false;
        let frameCount = 0;

        // Player State
        let players = {
            p1: { x: 0, distance: 0, speed: 0, color: '#58CC02', label: 'YOU' }, // Green
            p2: { x: 0, distance: 0, speed: 0, color: '#1CB0F6', label: 'RIVAL' }  // Blue
        };
        let me = 'p1';
        let them = 'p2';

        // Scenery Objects (Trees, bushes)
        let scenery = [];
        
        // Input
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false, a: false, d: false };

        // DOM
        const els = {
            lobby: document.getElementById('lobby'),
            loading: document.getElementById('loading-panel'),
            menu: document.getElementById('main-menu'),
            game: document.getElementById('game-container'),
            canvas: document.getElementById('gameCanvas'),
            myId: document.getElementById('my-peer-id'),
            joinBtn: document.getElementById('join-btn'),
            friendInput: document.getElementById('friend-id-input'),
            p1Bar: document.getElementById('p1-bar'),
            p2Bar: document.getElementById('p2-bar')
        };
        
        const ctx = els.canvas.getContext('2d');

        // --- INIT ---
        // Generate a 4-letter ID
        const generateId = () => {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let res = '';
            for(let i=0; i<4; i++) res += chars.charAt(Math.floor(Math.random() * chars.length));
            return res;
        };

        const shortId = generateId();
        peer = new Peer(shortId);

        peer.on('open', (id) => {
            els.loading.classList.add('hidden');
            els.menu.classList.remove('hidden');
            els.myId.innerText = id;
            myId = id;
        });

        peer.on('error', (err) => {
            // Fallback if ID taken (rare)
            if (err.type === 'unavailable-id') {
                location.reload(); 
            }
            console.error(err);
        });

        peer.on('connection', (connection) => {
            if (gameActive) return; // Busy
            handleConnection(connection);
        });

        // --- BUTTON HANDLERS ---
        
        // Single Player
        document.getElementById('single-player-btn').addEventListener('click', () => {
            isSinglePlayer = true;
            me = 'p1';
            them = 'p2';
            // Set rival color to red for single player to distinguish
            players.p2.color = '#FF4B4B'; 
            players.p2.label = 'BOT';
            startGame();
        });

        // Join Friend
        els.joinBtn.addEventListener('click', () => {
            const fid = els.friendInput.value.trim().toUpperCase();
            if (fid.length < 4) return;
            
            els.joinBtn.innerText = "CONNECTING...";
            conn = peer.connect(fid);
            
            conn.on('open', () => {
                // If I join, I am P2
                me = 'p2';
                them = 'p1';
                startGame();
            });

            handleConnection(conn);
        });

        function handleConnection(connection) {
            conn = connection;
            // Common handlers
            conn.on('data', (data) => {
                if (data.type === 'update') {
                    players[them].distance = data.distance;
                    players[them].x = data.x;
                } else if (data.type === 'gameover') {
                    endGame(data.winner);
                }
            });
            
            // If we received connection, start game
            if (!isSinglePlayer && conn.open) {
                 startGame();
            } else if (!isSinglePlayer) {
                conn.on('open', startGame);
            }
        }

        // --- GAME LOGIC ---
        function startGame() {
            els.lobby.classList.add('hidden');
            els.game.style.display = 'flex';
            resize();
            gameActive = true;
            generateScenery();
            requestAnimationFrame(loop);
        }

        function resize() {
            els.canvas.width = window.innerWidth;
            els.canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);

        // Input Listeners
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);
        window.addEventListener('touchstart', () => keys.ArrowUp = true);
        window.addEventListener('touchend', () => keys.ArrowUp = false);

        function loop() {
            if (!gameActive) return;
            update();
            draw();
            frameCount++;
            requestAnimationFrame(loop);
        }

        function update() {
            const p = players[me];

            // 1. My Physics
            if (keys.ArrowUp || keys.w) {
                p.speed < CONFIG.maxSpeed ? p.speed += 0.4 : p.speed = CONFIG.maxSpeed;
            } else {
                p.speed > 0 ? p.speed -= 0.3 : p.speed = 0;
            }
            // Simple lane logic
            if ((keys.ArrowLeft || keys.a) && p.x > -150) p.x -= 6;
            if ((keys.ArrowRight || keys.d) && p.x < 150) p.x += 6;

            p.distance += p.speed;

            // 2. Single Player AI
            if (isSinglePlayer) {
                const bot = players[them];
                // Rubber banding AI
                const diff = p.distance - bot.distance;
                let targetSpeed = CONFIG.maxSpeed * 0.92; // Base speed
                
                // If bot is far behind, speed up. If ahead, slow down.
                if (diff > 500) targetSpeed = CONFIG.maxSpeed * 1.1;
                if (diff < -500) targetSpeed = CONFIG.maxSpeed * 0.8;
                
                if (bot.speed < targetSpeed) bot.speed += 0.2;
                else bot.speed -= 0.2;
                
                bot.distance += bot.speed;
                // Simple sway
                bot.x = Math.sin(frameCount / 50) * 50;
            }

            // 3. Multiplayer Sync
            if (!isSinglePlayer && conn && conn.open && frameCount % 3 === 0) {
                conn.send({ type: 'update', distance: p.distance, x: p.x });
            }

            // 4. Win Condition
            if (p.distance >= CONFIG.totalDistance) {
                finish(me);
            } else if (players[them].distance >= CONFIG.totalDistance) {
                finish(them);
            }

            // 5. HUD
            els.p1Bar.style.width = `${Math.min(100, (players.p1.distance / CONFIG.totalDistance)*100)}%`;
            els.p2Bar.style.width = `${Math.min(100, (players.p2.distance / CONFIG.totalDistance)*100)}%`;
        }

        function finish(winner) {
            gameActive = false;
            if (!isSinglePlayer && conn && conn.open) {
                conn.send({ type: 'gameover', winner: winner });
            }
            endGame(winner);
        }

        // --- RENDERING ---
        
        // Procedural Scenery Generation
        function generateScenery() {
            // Create 50 random trees/bushes along the track
            for(let i=0; i<60; i++) {
                scenery.push({
                    z: Math.random() * CONFIG.totalDistance, // Position along track
                    side: Math.random() > 0.5 ? -1 : 1, // Left or Right
                    offset: 200 + Math.random() * 300, // Distance from road
                    type: Math.random() > 0.7 ? 'tree' : 'bush',
                    scale: 0.8 + Math.random() * 0.5,
                    color: Math.random() > 0.5 ? '#7bc43d' : '#6ab035'
                });
            }
            // Sort by Z so we draw far ones first (painter's algo doesn't apply strictly here due to perspective, but helpful)
            scenery.sort((a,b) => a.z - b.z);
        }

        function draw() {
            const w = els.canvas.width;
            const h = els.canvas.height;
            const cx = w / 2;
            const cy = h / 2;

            // 1. Sky
            const grd = ctx.createLinearGradient(0, 0, 0, h/2);
            grd.addColorStop(0, CONFIG.colors.skyTop);
            grd.addColorStop(1, CONFIG.colors.skyBottom);
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, w, h);

            // 2. Ground (Perspective illusion)
            // Just fill bottom half
            ctx.fillStyle = CONFIG.colors.grassLight;
            ctx.fillRect(0, h/2, w, h/2);

            // 3. Road Perspective
            // We use a simple 2.5D projection
            // Objects have a World Z (distance). Screen Y is proportional to 1/Z relative to camera.
            // Camera Z = players[me].distance
            
            // To keep it simple and clean like the previous version, we will stick to 
            // the vertical top-down-ish view but slanted, or just pure vertical scroll 
            // with perspective width. Let's do Vertical Scroll with Perspective Width.
            
            const camZ = players[me].distance;
            const roadW = w * CONFIG.roadWidthPercent;
            const horizonY = h * 0.3; // Horizon line height
            
            // Draw Ground Stripes
            const stripeH = 100;
            const groundOffset = -(camZ % (stripeH * 2));
            
            // Draw Scenery first (behind road?) No, scenery sits on ground.
            // We draw items that are visible.
            
            // Draw Road
            ctx.beginPath();
            ctx.fillStyle = CONFIG.colors.road;
            ctx.moveTo(cx - roadW * 0.1, horizonY); // Top Left (Vanishing point ish)
            ctx.lineTo(cx + roadW * 0.1, horizonY); // Top Right
            ctx.lineTo(cx + roadW/2, h);            // Bottom Right
            ctx.lineTo(cx - roadW/2, h);            // Bottom Left
            ctx.fill();

            // Draw Rumble Strips & Lane Markers
            // We iterate from near (bottom) to far (top)
            // However, iterating screen Y is easier.
            const totalStripes = 20;
            for(let i=0; i<totalStripes; i++) {
                // Perspective math: non-linear steps
                // Let's fake it with simple geometry for aesthetics
                let y = h - (h - horizonY) * (i / totalStripes);
                let nextY = h - (h - horizonY) * ((i+1) / totalStripes);
                
                let scale = 1 - (i/totalStripes); // 1 at bottom, 0 at top
                let nextScale = 1 - ((i+1)/totalStripes);

                let rw = (roadW/2) * (0.2 + 0.8*scale); // Road width at this Y
                
                // Movement
                let worldZ = camZ + (1000 * (i/totalStripes)); 
                let segmentColor = Math.floor(worldZ / 400) % 2 === 0; // Alternating segments

                // Rumble Strips
                if (segmentColor) {
                    ctx.fillStyle = CONFIG.colors.rumble2;
                    ctx.fillRect(cx - rw - 15*scale, nextY, 15*scale, y-nextY); // Left
                    ctx.fillRect(cx + rw, nextY, 15*scale, y-nextY); // Right
                } else {
                     ctx.fillStyle = CONFIG.colors.rumble1;
                    ctx.fillRect(cx - rw - 15*scale, nextY, 15*scale, y-nextY);
                    ctx.fillRect(cx + rw, nextY, 15*scale, y-nextY);
                }

                // Center Line
                if (Math.floor(worldZ / 200) % 2 === 0) {
                     ctx.fillStyle = "#FFF";
                     ctx.fillRect(cx - 2*scale, nextY, 4*scale, y-nextY);
                }
            }

            // 4. Draw Scenery Objects
            // Filter objects visible in front of camera
            const visibleScenery = scenery.filter(obj => obj.z > camZ - 200 && obj.z < camZ + 4000);
            
            // Sort: Furthest first (high Z) so near ones cover them
            visibleScenery.sort((a,b) => b.z - a.z);

            visibleScenery.forEach(obj => {
                // Projection
                let relZ = obj.z - camZ;
                let depth = relZ / 4000; // 0 (near) to 1 (far)
                if (depth < 0) depth = 0;
                
                let y = h - (h - horizonY) * (1 - Math.pow(1-depth, 2)); // Ease out
                let scale = (1 - depth); 
                
                // X position moves outward with perspective
                let xOffset = (obj.offset + roadW * 0.5) * scale * obj.side;
                let x = cx + xOffset;

                drawTree(ctx, x, y, scale * obj.scale, obj.color, obj.type);
            });

            // 5. Draw Cars
            // Me
            drawCar(ctx, cx + players[me].x, h - 120, players[me].color, true, players[me].label);

            // Opponent
            const distDiff = players[them].distance - players[me].distance;
            // Map distance to screen Y using the same perspective fake
            // This is tricky in 2.5D. We'll approximate.
            // If they are ahead (pos diff), they move up towards horizonY.
            // If behind, move down.
            
            let rivalScale = 1;
            let rivalY = h - 120;

            if (Math.abs(distDiff) < 3000) {
                // Simple linear map for demo
                rivalY -= distDiff * 0.4; 
                
                // Add scaling based on Y position (pseudo perspective)
                let progressToHorizon = (h - rivalY) / (h - horizonY);
                rivalScale = 1 - (progressToHorizon * 0.8);
                
                if (rivalY > horizonY && rivalY < h + 200) {
                     // Their X also needs to scale
                     let theirX = (cx + players[them].x * rivalScale);
                     // If behind, we need to invert perspective slightly or clamp
                     drawCar(ctx, theirX, rivalY, players[them].color, false, players[them].label, rivalScale);
                }
            }
        }

        function drawTree(ctx, x, y, s, color, type) {
            if (s <= 0) return;
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(s, s);

            if (type === 'tree') {
                // Trunk
                ctx.fillStyle = "#8d6e63";
                ctx.fillRect(-10, -20, 20, 20);
                // Leaves (Round)
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(0, -50, 40, 0, Math.PI*2);
                ctx.fill();
                // Shadow/Highlight
                ctx.fillStyle = "rgba(255,255,255,0.2)";
                ctx.beginPath();
                ctx.arc(-10, -60, 15, 0, Math.PI*2);
                ctx.fill();
            } else {
                // Bush
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(0, -10, 25, 0, Math.PI*2);
                ctx.arc(-20, 0, 15, 0, Math.PI*2);
                ctx.arc(20, 0, 15, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawCar(ctx, x, y, color, isMe, label, scale = 1) {
            const w = 70 * scale;
            const h = 50 * scale;
            
            ctx.save();
            ctx.translate(x, y);
            
            // Shadow
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.beginPath();
            ctx.ellipse(0, h/2, w/1.8, w/4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body
            ctx.fillStyle = color;
            // Simple curvy shape
            ctx.beginPath();
            ctx.roundRect(-w/2, -h/2, w, h, 15 * scale);
            ctx.fill();
            
            // Shine
            ctx.fillStyle = "rgba(255,255,255,0.2)";
            ctx.fillRect(-w/2, -h/2, w, h/2);

            // Windows
            ctx.fillStyle = "#333";
            ctx.beginPath();
            ctx.roundRect(-w/2 + 5*scale, -h/2 + 5*scale, w - 10*scale, h*0.4, 5*scale);
            ctx.fill();

            // Label
            if (scale > 0.4) {
                ctx.fillStyle = "white";
                ctx.font = `900 ${14*scale}px Nunito`;
                ctx.textAlign = "center";
                ctx.fillText(label, 0, -h/2 - 10*scale);
            }
            
            ctx.restore();
        }

        function endGame(winner) {
            const modal = document.getElementById('modal-overlay');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-msg');
            
            modal.style.display = 'flex';
            
            if (winner === me) {
                title.innerText = "VICTORY!";
                title.style.color = "#58CC02";
                msg.innerText = isSinglePlayer ? "You beat the bot!" : "You beat your friend!";
            } else {
                title.innerText = "SECOND PLACE";
                title.style.color = "#FF4B4B";
                msg.innerText = "Nice try!";
            }
        }
    </script>
</body>
</html>